"""HubSpot schema sync and tool generation.

This module:
1. Fetches the HubSpot schema (object types and their properties)
2. Generates strongly-typed Python tools for each object type
3. Writes the generated code to tools_generated.py
"""

from pathlib import Path
from typing import Any

from sdrbot_cli.auth.hubspot import get_client
from sdrbot_cli.services.registry import compute_schema_hash


# Standard HubSpot objects that are always available
STANDARD_OBJECTS = ["contacts", "companies", "deals", "tickets", "line_items", "products", "quotes"]

# Properties to exclude from generated tools (system/internal properties)
EXCLUDED_PROPERTY_PREFIXES = [
    "hs_",  # HubSpot system properties
    "hubspot_",
]

# Properties to always include even if they start with excluded prefix
INCLUDED_PROPERTIES = [
    "hs_lead_status",
    "hs_pipeline",
    "hs_pipeline_stage",
]

# Maximum properties per tool to keep signatures manageable
MAX_PROPERTIES_PER_TOOL = 25


def sync_schema() -> dict[str, Any]:
    """Fetch HubSpot schema and generate tools.

    Returns:
        Dict with keys:
        - schema_hash: Hash of the schema for change detection
        - objects: List of object names that were synced
    """
    hs = get_client()

    # 1. Discover all object types (standard + custom)
    all_objects = _discover_objects(hs)

    # 2. Fetch properties for each object
    objects_schema = {}
    for obj_type in all_objects:
        try:
            props = _fetch_object_properties(hs, obj_type)
            if props:  # Only include objects we can access
                objects_schema[obj_type] = props
        except Exception:
            # Skip objects we can't access (permissions, etc.)
            continue

    # 3. Generate the tools code
    generated_code = _generate_tools_code(objects_schema)

    # 4. Write to tools_generated.py
    output_path = Path(__file__).parent / "tools_generated.py"
    output_path.write_text(generated_code, encoding="utf-8")

    # 5. Return metadata
    return {
        "schema_hash": compute_schema_hash(objects_schema),
        "objects": list(objects_schema.keys()),
    }


def _discover_objects(hs) -> list[str]:
    """Discover all available HubSpot object types.

    Args:
        hs: HubSpot client instance.

    Returns:
        List of object type names (e.g., ["contacts", "companies", "2-12345"])
    """
    objects = set(STANDARD_OBJECTS)

    try:
        # Get custom objects from schemas API
        response = hs.crm.schemas.core_api.get_all()
        for schema in response.results:
            objects.add(schema.name)
    except Exception:
        # If schemas API fails, just use standard objects
        pass

    return sorted(objects)


def _fetch_object_properties(hs, object_type: str) -> list[dict[str, Any]]:
    """Fetch properties for a specific object type.

    Args:
        hs: HubSpot client instance.
        object_type: The object type (e.g., "contacts").

    Returns:
        List of property dictionaries with name, label, type, etc.
    """
    response = hs.crm.properties.core_api.get_all(object_type=object_type)

    properties = []
    for p in response.results:
        # Skip hidden properties
        if p.hidden:
            continue

        # Check if property should be excluded
        prop_name = p.name
        is_excluded = any(prop_name.startswith(prefix) for prefix in EXCLUDED_PROPERTY_PREFIXES)
        is_included = prop_name in INCLUDED_PROPERTIES

        if is_excluded and not is_included:
            continue

        # Check if read-only
        read_only = False
        if p.modification_metadata:
            read_only = p.modification_metadata.read_only_value

        # Get options for enumeration types
        options = []
        if p.options:
            options = [o.value for o in p.options if not o.hidden]

        properties.append({
            "name": prop_name,
            "label": p.label,
            "type": p.type,
            "field_type": p.field_type,
            "required": getattr(p, "has_unique_value", False) or False,
            "read_only": read_only,
            "options": options[:20],  # Limit options to keep code manageable
            "description": p.description or "",
        })

    return properties


def _generate_tools_code(schema: dict[str, list[dict]]) -> str:
    """Generate Python tool code from schema.

    Args:
        schema: Dict mapping object types to their properties.

    Returns:
        Python source code as a string.
    """
    lines = [
        '"""HubSpot generated tools - AUTO-GENERATED by sync. Do not edit manually.',
        '',
        'This file is regenerated when you run: /services sync hubspot',
        'To customize, edit tools.py instead (static tools).',
        '"""',
        '',
        'import json',
        'from typing import Optional',
        '',
        'from langchain_core.tools import tool',
        '',
        'from sdrbot_cli.auth.hubspot import get_client',
        'from hubspot.crm.objects import (',
        '    PublicObjectSearchRequest,',
        '    SimplePublicObjectInput,',
        '    SimplePublicObjectInputForCreate,',
        ')',
        '',
        '',
        '# Shared client instance',
        '_hs_client = None',
        '',
        '',
        'def _get_hs():',
        '    """Get or create HubSpot client instance."""',
        '    global _hs_client',
        '    if _hs_client is None:',
        '        _hs_client = get_client()',
        '    if _hs_client is None:',
        '        raise RuntimeError("HubSpot authentication failed. Check HUBSPOT_ACCESS_TOKEN in .env")',
        '    return _hs_client',
        '',
        '',
    ]

    for obj_type, properties in schema.items():
        # Filter to writable properties for create/update
        writable_props = [p for p in properties if not p.get("read_only")]

        # Prioritize important properties
        writable_props = _prioritize_properties(writable_props, obj_type)

        # Limit properties per tool
        create_props = writable_props[:MAX_PROPERTIES_PER_TOOL]
        search_props = [p for p in properties if p["type"] in ("string", "number", "enumeration")][:15]

        # Generate create tool
        lines.extend(_generate_create_tool(obj_type, create_props))
        lines.append("")

        # Generate update tool
        lines.extend(_generate_update_tool(obj_type, create_props))
        lines.append("")

        # Generate search tool
        lines.extend(_generate_search_tool(obj_type, search_props))
        lines.append("")

        # Generate get tool
        lines.extend(_generate_get_tool(obj_type))
        lines.append("")

        # Generate delete tool
        lines.extend(_generate_delete_tool(obj_type))
        lines.append("")

    return "\n".join(lines)


def _prioritize_properties(properties: list[dict], obj_type: str) -> list[dict]:
    """Sort properties by importance for the given object type.

    Args:
        properties: List of property dicts.
        obj_type: Object type name.

    Returns:
        Sorted list with most important properties first.
    """
    # Priority properties by object type
    priority_map = {
        "contacts": ["email", "firstname", "lastname", "phone", "company", "jobtitle", "lifecyclestage"],
        "companies": ["name", "domain", "industry", "phone", "city", "state", "country"],
        "deals": ["dealname", "amount", "dealstage", "pipeline", "closedate"],
        "tickets": ["subject", "content", "hs_pipeline", "hs_pipeline_stage", "hs_ticket_priority"],
    }

    priority_names = priority_map.get(obj_type, [])

    def sort_key(p):
        name = p["name"]
        if name in priority_names:
            return (0, priority_names.index(name))
        if p.get("required"):
            return (1, name)
        return (2, name)

    return sorted(properties, key=sort_key)


def _python_type(hubspot_type: str, options: list[str] = None) -> str:
    """Map HubSpot types to Python types.

    Args:
        hubspot_type: HubSpot property type.
        options: List of valid options for enumeration types.

    Returns:
        Python type annotation string.
    """
    type_mapping = {
        "string": "str",
        "number": "float",
        "date": "str",
        "datetime": "str",
        "enumeration": "str",
        "bool": "bool",
        "phone_number": "str",
    }
    return type_mapping.get(hubspot_type, "str")


def _singularize(name: str) -> str:
    """Convert plural object name to singular.

    Args:
        name: Plural name (e.g., "contacts").

    Returns:
        Singular name (e.g., "contact").
    """
    if name.endswith("ies"):
        return name[:-3] + "y"
    if name.endswith("s") and not name.endswith("ss"):
        return name[:-1]
    return name


def _generate_create_tool(obj_type: str, properties: list[dict]) -> list[str]:
    """Generate a create tool for an object type.

    Args:
        obj_type: Object type name.
        properties: List of property dicts.

    Returns:
        List of code lines.
    """
    singular = _singularize(obj_type)
    func_name = f"hubspot_create_{singular}"

    # Build parameter list
    params = []
    for p in properties:
        param_type = _python_type(p["type"], p.get("options"))
        default = " = None"
        params.append(f"    {p['name']}: Optional[{param_type}]{default},")

    params_str = "\n".join(params) if params else "    # No writable properties"

    # Build docstring
    doc_lines = [f'    """Create a new {singular} in HubSpot.']
    doc_lines.append("")
    doc_lines.append("    Args:")
    for p in properties[:15]:  # Limit docstring length
        desc = p.get("label", p["name"])
        if p.get("options"):
            desc += f" (options: {', '.join(p['options'][:5])})"
        doc_lines.append(f"        {p['name']}: {desc}")
    if len(properties) > 15:
        doc_lines.append(f"        ... and {len(properties) - 15} more parameters")
    doc_lines.append("")
    doc_lines.append("    Returns:")
    doc_lines.append(f"        Success message with the new {singular} ID.")
    doc_lines.append('    """')

    # Build function body
    body = [
        "    hs = _get_hs()",
        "    try:",
        "        # Build properties dict from non-None arguments",
        "        props = {}",
        "        local_vars = locals()",
        "        param_names = [",
    ]

    # Add parameter names
    for p in properties:
        body.append(f"            '{p['name']}',")

    body.extend([
        "        ]",
        "        for name in param_names:",
        "            value = local_vars.get(name)",
        "            if value is not None:",
        "                props[name] = str(value) if not isinstance(value, bool) else value",
        "",
        "        if not props:",
        f'            return "Error: At least one property must be provided to create a {singular}."',
        "",
        "        input_obj = SimplePublicObjectInputForCreate(properties=props, associations=[])",
        f'        response = hs.crm.objects.basic_api.create(object_type="{obj_type}", simple_public_object_input_for_create=input_obj)',
        "",
        f'        return f"Successfully created {singular} with ID: {{response.id}}"',
        "    except Exception as e:",
        f'        return f"Error creating {singular}: {{str(e)}}"',
    ])

    return [
        "@tool",
        f"def {func_name}(",
        params_str,
        ") -> str:",
        *doc_lines,
        *body,
    ]


def _generate_update_tool(obj_type: str, properties: list[dict]) -> list[str]:
    """Generate an update tool for an object type.

    Args:
        obj_type: Object type name.
        properties: List of property dicts.

    Returns:
        List of code lines.
    """
    singular = _singularize(obj_type)
    func_name = f"hubspot_update_{singular}"

    # Build parameter list (id is required, others optional)
    params = [f"    {singular}_id: str,"]
    for p in properties:
        param_type = _python_type(p["type"], p.get("options"))
        params.append(f"    {p['name']}: Optional[{param_type}] = None,")

    params_str = "\n".join(params)

    # Build docstring
    doc_lines = [f'    """Update an existing {singular} in HubSpot.']
    doc_lines.append("")
    doc_lines.append("    Args:")
    doc_lines.append(f"        {singular}_id: The HubSpot ID of the {singular} to update.")
    for p in properties[:10]:
        desc = p.get("label", p["name"])
        doc_lines.append(f"        {p['name']}: {desc}")
    if len(properties) > 10:
        doc_lines.append(f"        ... and {len(properties) - 10} more parameters")
    doc_lines.append("")
    doc_lines.append("    Returns:")
    doc_lines.append("        Success message confirming the update.")
    doc_lines.append('    """')

    # Build function body
    body = [
        "    hs = _get_hs()",
        "    try:",
        "        # Build properties dict from non-None arguments",
        "        props = {}",
        "        local_vars = locals()",
        "        param_names = [",
    ]

    for p in properties:
        body.append(f"            '{p['name']}',")

    body.extend([
        "        ]",
        "        for name in param_names:",
        "            value = local_vars.get(name)",
        "            if value is not None:",
        "                props[name] = str(value) if not isinstance(value, bool) else value",
        "",
        "        if not props:",
        '            return "Error: At least one property must be provided to update."',
        "",
        "        input_obj = SimplePublicObjectInput(properties=props)",
        f"        response = hs.crm.objects.basic_api.update(",
        f'            object_type="{obj_type}",',
        f"            object_id={singular}_id,",
        "            simple_public_object_input=input_obj",
        "        )",
        "",
        f'        return f"Successfully updated {singular} {{{singular}_id}}"',
        "    except Exception as e:",
        f'        return f"Error updating {singular}: {{str(e)}}"',
    ])

    return [
        "@tool",
        f"def {func_name}(",
        params_str,
        ") -> str:",
        *doc_lines,
        *body,
    ]


def _generate_search_tool(obj_type: str, properties: list[dict]) -> list[str]:
    """Generate a search tool for an object type.

    Args:
        obj_type: Object type name.
        properties: List of searchable property dicts.

    Returns:
        List of code lines.
    """
    singular = _singularize(obj_type)
    func_name = f"hubspot_search_{obj_type}"

    # Build parameter list
    params = ["    query: Optional[str] = None,"]
    for p in properties[:10]:  # Limit search parameters
        param_type = _python_type(p["type"])
        params.append(f"    {p['name']}: Optional[{param_type}] = None,")
    params.append("    limit: int = 10,")

    params_str = "\n".join(params)

    # Property names for search
    prop_names = [p["name"] for p in properties[:10]]

    # Build docstring
    doc_lines = [f'    """Search for {obj_type} in HubSpot.']
    doc_lines.append("")
    doc_lines.append("    You can search by free-text query OR by specific field values.")
    doc_lines.append("")
    doc_lines.append("    Args:")
    doc_lines.append("        query: Free-text search query (searches across all fields).")
    for p in properties[:10]:
        doc_lines.append(f"        {p['name']}: Filter by {p.get('label', p['name'])}.")
    doc_lines.append("        limit: Maximum results to return (default 10).")
    doc_lines.append("")
    doc_lines.append("    Returns:")
    doc_lines.append(f"        JSON string with matching {obj_type}.")
    doc_lines.append('    """')

    body = [
        "    hs = _get_hs()",
        "    try:",
        "        search_request = PublicObjectSearchRequest(limit=limit)",
        "",
        "        if query:",
        "            search_request.query = query",
        "        else:",
        "            # Build filters from provided parameters",
        "            filters = []",
        "            local_vars = locals()",
        f"            filter_params = {prop_names}",
        "            for name in filter_params:",
        "                value = local_vars.get(name)",
        "                if value is not None:",
        '                    filters.append({"propertyName": name, "operator": "EQ", "value": str(value)})',
        "",
        "            if filters:",
        '                search_request.filter_groups = [{"filters": filters}]',
        "",
        "        # Request common properties",
        f"        search_request.properties = {prop_names[:7]}",
        "",
        f'        response = hs.crm.objects.search_api.do_search(object_type="{obj_type}", public_object_search_request=search_request)',
        "",
        "        if not response.results:",
        f'            return "No {obj_type} found."',
        "",
        "        results = []",
        "        for r in response.results:",
        '            results.append({"id": r.id, "properties": r.properties})',
        "",
        f'        return f"Found {{response.total}} {obj_type}:\\n" + json.dumps(results, indent=2)',
        "    except Exception as e:",
        f'        return f"Error searching {obj_type}: {{str(e)}}"',
    ]

    return [
        "@tool",
        f"def {func_name}(",
        params_str,
        ") -> str:",
        *doc_lines,
        *body,
    ]


def _generate_get_tool(obj_type: str) -> list[str]:
    """Generate a get-by-id tool for an object type.

    Args:
        obj_type: Object type name.

    Returns:
        List of code lines.
    """
    singular = _singularize(obj_type)
    func_name = f"hubspot_get_{singular}"

    return [
        "@tool",
        f"def {func_name}({singular}_id: str) -> str:",
        f'    """Get a {singular} by ID from HubSpot.',
        "",
        "    Args:",
        f"        {singular}_id: The HubSpot ID of the {singular}.",
        "",
        "    Returns:",
        f"        JSON string with the {singular} details.",
        '    """',
        "    hs = _get_hs()",
        "    try:",
        f'        response = hs.crm.objects.basic_api.get_by_id(object_type="{obj_type}", object_id={singular}_id)',
        f'        return f"{singular.title()} {{response.id}}:\\n" + json.dumps(response.properties, indent=2)',
        "    except Exception as e:",
        f'        return f"Error getting {singular}: {{str(e)}}"',
    ]


def _generate_delete_tool(obj_type: str) -> list[str]:
    """Generate a delete tool for an object type.

    Args:
        obj_type: Object type name.

    Returns:
        List of code lines.
    """
    singular = _singularize(obj_type)
    func_name = f"hubspot_delete_{singular}"

    return [
        "@tool",
        f"def {func_name}({singular}_id: str) -> str:",
        f'    """Delete (archive) a {singular} in HubSpot.',
        "",
        "    Args:",
        f"        {singular}_id: The HubSpot ID of the {singular} to delete.",
        "",
        "    Returns:",
        "        Success message confirming deletion.",
        '    """',
        "    hs = _get_hs()",
        "    try:",
        f'        hs.crm.objects.basic_api.archive(object_type="{obj_type}", object_id={singular}_id)',
        f'        return f"Successfully deleted {singular} {{{singular}_id}}"',
        "    except Exception as e:",
        f'        return f"Error deleting {singular}: {{str(e)}}"',
    ]
