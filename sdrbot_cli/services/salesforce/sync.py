"""Salesforce schema sync and tool generation.

This module:
1. Fetches the Salesforce schema (object types and their fields)
2. Generates strongly-typed Python tools for each object type
3. Writes the generated code to tools_generated.py
"""

from pathlib import Path
from typing import Any

from sdrbot_cli.auth.salesforce import get_client
from sdrbot_cli.services.registry import compute_schema_hash


# Standard Salesforce objects to sync by default
STANDARD_OBJECTS = ["Lead", "Contact", "Account", "Opportunity", "Case", "Task", "Event"]

# Fields to exclude from generated tools (system fields)
EXCLUDED_FIELD_SUFFIXES = ["__c"]  # We actually WANT custom fields
EXCLUDED_FIELDS = [
    "Id", "IsDeleted", "MasterRecordId", "CreatedDate", "CreatedById",
    "LastModifiedDate", "LastModifiedById", "SystemModstamp", "LastActivityDate",
    "LastViewedDate", "LastReferencedDate", "PhotoUrl", "JigsawContactId",
]

# Maximum fields per tool to keep signatures manageable
MAX_FIELDS_PER_TOOL = 25


def sync_schema() -> dict[str, Any]:
    """Fetch Salesforce schema and generate tools.

    Returns:
        Dict with keys:
        - schema_hash: Hash of the schema for change detection
        - objects: List of object names that were synced
    """
    sf = get_client()

    # 1. Discover all object types
    all_objects = _discover_objects(sf)

    # 2. Fetch fields for each object
    objects_schema = {}
    for obj_name in all_objects:
        try:
            fields = _fetch_object_fields(sf, obj_name)
            if fields:  # Only include objects we can access
                objects_schema[obj_name] = fields
        except Exception:
            # Skip objects we can't access
            continue

    # 3. Generate the tools code
    generated_code = _generate_tools_code(objects_schema)

    # 4. Write to tools_generated.py
    output_path = Path(__file__).parent / "tools_generated.py"
    output_path.write_text(generated_code, encoding="utf-8")

    # 5. Return metadata
    return {
        "schema_hash": compute_schema_hash(objects_schema),
        "objects": list(objects_schema.keys()),
    }


def _discover_objects(sf) -> list[str]:
    """Discover available Salesforce object types.

    Args:
        sf: Salesforce client instance.

    Returns:
        List of object API names.
    """
    objects = set(STANDARD_OBJECTS)

    try:
        # Get all objects from describe
        desc = sf.describe()
        for obj in desc.get("sobjects", []):
            # Include standard objects and custom objects
            if obj.get("createable") and obj.get("queryable"):
                name = obj.get("name")
                # Include custom objects (end with __c)
                if name.endswith("__c") or name in STANDARD_OBJECTS:
                    objects.add(name)
    except Exception:
        pass

    return sorted(objects)


def _fetch_object_fields(sf, object_name: str) -> list[dict[str, Any]]:
    """Fetch fields for a specific object type.

    Args:
        sf: Salesforce client instance.
        object_name: The object API name (e.g., "Contact").

    Returns:
        List of field dictionaries.
    """
    desc = sf.restful(f"sobjects/{object_name}/describe")

    fields = []
    for f in desc.get("fields", []):
        name = f.get("name")

        # Skip excluded fields
        if name in EXCLUDED_FIELDS:
            continue

        # Check if createable or updateable
        createable = f.get("createable", False)
        updateable = f.get("updateable", False)

        if not createable and not updateable:
            continue

        # Determine if required
        required = not f.get("nillable", True) and not f.get("defaultedOnCreate", False)

        # Get picklist values
        options = []
        if f.get("type") == "picklist":
            options = [p.get("value") for p in f.get("picklistValues", []) if p.get("active")]

        # Get reference info
        references = []
        if f.get("type") == "reference":
            references = f.get("referenceTo", [])

        fields.append({
            "name": name,
            "label": f.get("label", name),
            "type": f.get("type"),
            "required": required,
            "createable": createable,
            "updateable": updateable,
            "options": options[:20],
            "references": references,
            "length": f.get("length"),
        })

    return fields


def _generate_tools_code(schema: dict[str, list[dict]]) -> str:
    """Generate Python tool code from schema.

    Args:
        schema: Dict mapping object names to their fields.

    Returns:
        Python source code as a string.
    """
    lines = [
        '"""Salesforce generated tools - AUTO-GENERATED by sync. Do not edit manually.',
        '',
        'This file is regenerated when you run: /services sync salesforce',
        'To customize, edit tools.py instead (static tools like SOQL).',
        '"""',
        '',
        'import json',
        'from typing import Optional',
        '',
        'from langchain_core.tools import tool',
        '',
        'from sdrbot_cli.auth.salesforce import get_client',
        '',
        '',
        '# Shared client instance',
        '_sf_client = None',
        '',
        '',
        'def _get_sf():',
        '    """Get or create Salesforce client instance."""',
        '    global _sf_client',
        '    if _sf_client is None:',
        '        _sf_client = get_client()',
        '    return _sf_client',
        '',
        '',
    ]

    for obj_name, fields in schema.items():
        # Filter to createable fields for create tool
        createable_fields = [f for f in fields if f.get("createable")]
        updateable_fields = [f for f in fields if f.get("updateable")]

        # Prioritize and limit fields
        createable_fields = _prioritize_fields(createable_fields, obj_name)[:MAX_FIELDS_PER_TOOL]
        updateable_fields = _prioritize_fields(updateable_fields, obj_name)[:MAX_FIELDS_PER_TOOL]

        # Generate create tool
        if createable_fields:
            lines.extend(_generate_create_tool(obj_name, createable_fields))
            lines.append("")

        # Generate update tool
        if updateable_fields:
            lines.extend(_generate_update_tool(obj_name, updateable_fields))
            lines.append("")

        # Generate get tool
        lines.extend(_generate_get_tool(obj_name))
        lines.append("")

        # Generate delete tool
        lines.extend(_generate_delete_tool(obj_name))
        lines.append("")

    return "\n".join(lines)


def _prioritize_fields(fields: list[dict], obj_name: str) -> list[dict]:
    """Sort fields by importance.

    Args:
        fields: List of field dicts.
        obj_name: Object name.

    Returns:
        Sorted list with most important fields first.
    """
    priority_map = {
        "Lead": ["LastName", "Company", "Email", "Phone", "FirstName", "Title", "Status"],
        "Contact": ["LastName", "FirstName", "Email", "Phone", "AccountId", "Title"],
        "Account": ["Name", "Industry", "Phone", "Website", "BillingCity", "BillingState"],
        "Opportunity": ["Name", "StageName", "Amount", "CloseDate", "AccountId"],
        "Case": ["Subject", "Description", "Status", "Priority", "ContactId", "AccountId"],
    }

    priority_names = priority_map.get(obj_name, [])

    def sort_key(f):
        name = f["name"]
        if name in priority_names:
            return (0, priority_names.index(name))
        if f.get("required"):
            return (1, name)
        return (2, name)

    return sorted(fields, key=sort_key)


def _python_type(sf_type: str) -> str:
    """Map Salesforce types to Python types.

    Args:
        sf_type: Salesforce field type.

    Returns:
        Python type annotation string.
    """
    type_mapping = {
        "string": "str",
        "textarea": "str",
        "email": "str",
        "phone": "str",
        "url": "str",
        "picklist": "str",
        "multipicklist": "str",
        "reference": "str",
        "id": "str",
        "boolean": "bool",
        "int": "int",
        "double": "float",
        "currency": "float",
        "percent": "float",
        "date": "str",
        "datetime": "str",
    }
    return type_mapping.get(sf_type, "str")


def _generate_create_tool(obj_name: str, fields: list[dict]) -> list[str]:
    """Generate a create tool for an object.

    Args:
        obj_name: Object API name.
        fields: List of createable fields.

    Returns:
        List of code lines.
    """
    func_name = f"salesforce_create_{obj_name.lower().replace('__c', '')}"

    # Build parameter list
    params = []
    for f in fields:
        param_type = _python_type(f["type"])
        default = "" if f.get("required") else " = None"
        type_hint = param_type if f.get("required") else f"Optional[{param_type}]"
        params.append(f"    {f['name']}: {type_hint}{default},")

    params_str = "\n".join(params) if params else "    # No createable fields"

    # Build docstring
    doc_lines = [f'    """Create a new {obj_name} record in Salesforce.']
    doc_lines.append("")
    doc_lines.append("    Args:")
    for f in fields[:15]:
        desc = f.get("label", f["name"])
        if f.get("options"):
            desc += f" (options: {', '.join(f['options'][:5])})"
        if f.get("references"):
            desc += f" (references: {', '.join(f['references'])})"
        req = " [REQUIRED]" if f.get("required") else ""
        doc_lines.append(f"        {f['name']}: {desc}{req}")
    if len(fields) > 15:
        doc_lines.append(f"        ... and {len(fields) - 15} more parameters")
    doc_lines.append("")
    doc_lines.append("    Returns:")
    doc_lines.append(f"        Success message with the new {obj_name} ID.")
    doc_lines.append('    """')

    # Build function body
    body = [
        "    sf = _get_sf()",
        "    try:",
        "        # Build data dict from non-None arguments",
        "        data = {}",
        "        local_vars = locals()",
        "        param_names = [",
    ]

    for f in fields:
        body.append(f"            '{f['name']}',")

    body.extend([
        "        ]",
        "        for name in param_names:",
        "            value = local_vars.get(name)",
        "            if value is not None:",
        "                data[name] = value",
        "",
        "        if not data:",
        f'            return "Error: At least one field must be provided to create a {obj_name}."',
        "",
        f'        result = sf.restful("sobjects/{obj_name}", method="POST", json=data)',
        "",
        '        if result.get("success"):',
        f'            return f"Successfully created {obj_name} with ID: {{result[\'id\']}}"',
        "        else:",
        '            return f"Failed to create {obj_name}: {result}"',
        "    except Exception as e:",
        f'        return f"Error creating {obj_name}: {{str(e)}}"',
    ])

    return [
        "@tool",
        f"def {func_name}(",
        params_str,
        ") -> str:",
        *doc_lines,
        *body,
    ]


def _generate_update_tool(obj_name: str, fields: list[dict]) -> list[str]:
    """Generate an update tool for an object.

    Args:
        obj_name: Object API name.
        fields: List of updateable fields.

    Returns:
        List of code lines.
    """
    func_name = f"salesforce_update_{obj_name.lower().replace('__c', '')}"

    # Build parameter list (id is required)
    params = ["    record_id: str,"]
    for f in fields:
        param_type = _python_type(f["type"])
        params.append(f"    {f['name']}: Optional[{param_type}] = None,")

    params_str = "\n".join(params)

    # Build docstring
    doc_lines = [f'    """Update an existing {obj_name} record in Salesforce.']
    doc_lines.append("")
    doc_lines.append("    Args:")
    doc_lines.append(f"        record_id: The Salesforce ID of the {obj_name} to update.")
    for f in fields[:10]:
        desc = f.get("label", f["name"])
        doc_lines.append(f"        {f['name']}: {desc}")
    if len(fields) > 10:
        doc_lines.append(f"        ... and {len(fields) - 10} more parameters")
    doc_lines.append("")
    doc_lines.append("    Returns:")
    doc_lines.append("        Success message confirming the update.")
    doc_lines.append('    """')

    # Build function body
    body = [
        "    sf = _get_sf()",
        "    try:",
        "        # Build data dict from non-None arguments",
        "        data = {}",
        "        local_vars = locals()",
        "        param_names = [",
    ]

    for f in fields:
        body.append(f"            '{f['name']}',")

    body.extend([
        "        ]",
        "        for name in param_names:",
        "            value = local_vars.get(name)",
        "            if value is not None:",
        "                data[name] = value",
        "",
        "        if not data:",
        '            return "Error: At least one field must be provided to update."',
        "",
        f'        sf.restful(f"sobjects/{obj_name}/{{record_id}}", method="PATCH", json=data)',
        f'        return f"Successfully updated {obj_name} {{record_id}}"',
        "    except Exception as e:",
        f'        return f"Error updating {obj_name}: {{str(e)}}"',
    ])

    return [
        "@tool",
        f"def {func_name}(",
        params_str,
        ") -> str:",
        *doc_lines,
        *body,
    ]


def _generate_get_tool(obj_name: str) -> list[str]:
    """Generate a get-by-id tool for an object.

    Args:
        obj_name: Object API name.

    Returns:
        List of code lines.
    """
    func_name = f"salesforce_get_{obj_name.lower().replace('__c', '')}"

    return [
        "@tool",
        f"def {func_name}(record_id: str) -> str:",
        f'    """Get a {obj_name} record by ID from Salesforce.',
        "",
        "    Args:",
        f"        record_id: The Salesforce ID of the {obj_name}.",
        "",
        "    Returns:",
        f"        JSON string with the {obj_name} details.",
        '    """',
        "    sf = _get_sf()",
        "    try:",
        f'        result = sf.restful(f"sobjects/{obj_name}/{{record_id}}")',
        "        # Remove metadata",
        '        if "attributes" in result:',
        '            del result["attributes"]',
        f'        return f"{obj_name} {{record_id}}:\\n" + json.dumps(result, indent=2)',
        "    except Exception as e:",
        f'        return f"Error getting {obj_name}: {{str(e)}}"',
    ]


def _generate_delete_tool(obj_name: str) -> list[str]:
    """Generate a delete tool for an object.

    Args:
        obj_name: Object API name.

    Returns:
        List of code lines.
    """
    func_name = f"salesforce_delete_{obj_name.lower().replace('__c', '')}"

    return [
        "@tool",
        f"def {func_name}(record_id: str) -> str:",
        f'    """Delete a {obj_name} record from Salesforce.',
        "",
        "    Args:",
        f"        record_id: The Salesforce ID of the {obj_name} to delete.",
        "",
        "    Returns:",
        "        Success message confirming deletion.",
        '    """',
        "    sf = _get_sf()",
        "    try:",
        f'        sf.restful(f"sobjects/{obj_name}/{{record_id}}", method="DELETE")',
        f'        return f"Successfully deleted {obj_name} {{record_id}}"',
        "    except Exception as e:",
        f'        return f"Error deleting {obj_name}: {{str(e)}}"',
    ]
