"""Attio schema sync and tool generation.

This module:
1. Fetches the Attio schema (objects and their attributes)
2. Generates strongly-typed Python tools for each object type
3. Writes the generated code to tools_generated.py
"""

from pathlib import Path
from typing import Any

from sdrbot_cli.auth.attio import AttioClient
from sdrbot_cli.services.registry import compute_schema_hash


# Maximum attributes per tool to keep signatures manageable
MAX_ATTRIBUTES_PER_TOOL = 25


def sync_schema() -> dict[str, Any]:
    """Fetch Attio schema and generate tools.

    Returns:
        Dict with keys:
        - schema_hash: Hash of the schema for change detection
        - objects: List of object slugs that were synced
    """
    client = AttioClient()

    # 1. Discover all object types
    all_objects = _discover_objects(client)

    # 2. Fetch attributes for each object
    objects_schema = {}
    for obj in all_objects:
        try:
            attributes = _fetch_object_attributes(client, obj["api_slug"])
            if attributes:
                objects_schema[obj["api_slug"]] = {
                    "singular_noun": obj["singular_noun"],
                    "plural_noun": obj["plural_noun"],
                    "attributes": attributes,
                }
        except Exception:
            continue

    # 3. Generate the tools code
    generated_code = _generate_tools_code(objects_schema)

    # 4. Write to tools_generated.py
    output_path = Path(__file__).parent / "tools_generated.py"
    output_path.write_text(generated_code, encoding="utf-8")

    # 5. Return metadata
    return {
        "schema_hash": compute_schema_hash(objects_schema),
        "objects": list(objects_schema.keys()),
    }


def _discover_objects(client: AttioClient) -> list[dict[str, Any]]:
    """Discover available Attio object types.

    Args:
        client: Attio client instance.

    Returns:
        List of object info dicts with api_slug, singular_noun, plural_noun.
    """
    response = client.request("GET", "/objects")
    objects = response.get("data", [])

    return [
        {
            "api_slug": obj["api_slug"],
            "singular_noun": obj["singular_noun"],
            "plural_noun": obj["plural_noun"],
        }
        for obj in objects
    ]


def _fetch_object_attributes(client: AttioClient, object_slug: str) -> list[dict[str, Any]]:
    """Fetch attributes for a specific object type.

    Args:
        client: Attio client instance.
        object_slug: The object's api_slug.

    Returns:
        List of attribute dictionaries.
    """
    response = client.request("GET", f"/objects/{object_slug}/attributes")
    attributes = response.get("data", [])

    result = []
    for attr in attributes:
        # Skip inactive attributes
        if attr.get("status") != "active":
            continue

        # Get attribute info
        attr_type = attr.get("type")
        is_required = attr.get("is_required", False)
        is_writable = attr.get("is_writable", True)

        # Skip read-only attributes
        if not is_writable:
            continue

        # Get options for select types
        options = []
        config = attr.get("config", {})
        if attr_type == "select":
            select_config = config.get("select", {})
            options = [o.get("title") for o in select_config.get("options", [])]

        result.append({
            "api_slug": attr.get("api_slug"),
            "title": attr.get("title"),
            "type": attr_type,
            "required": is_required,
            "options": options[:20],
        })

    return result


def _generate_tools_code(schema: dict[str, dict]) -> str:
    """Generate Python tool code from schema.

    Args:
        schema: Dict mapping object slugs to their info and attributes.

    Returns:
        Python source code as a string.
    """
    lines = [
        '"""Attio generated tools - AUTO-GENERATED by sync. Do not edit manually.',
        '',
        'This file is regenerated when you run: /services sync attio',
        'To customize, edit tools.py instead (static tools like notes).',
        '"""',
        '',
        'import json',
        'from typing import Optional',
        '',
        'from langchain_core.tools import tool',
        '',
        'from sdrbot_cli.auth.attio import AttioClient',
        '',
        '',
        '# Shared client instance',
        '_attio_client = None',
        '',
        '',
        'def _get_attio():',
        '    """Get or create Attio client instance."""',
        '    global _attio_client',
        '    if _attio_client is None:',
        '        _attio_client = AttioClient()',
        '    return _attio_client',
        '',
        '',
        'def _format_attio_value(value):',
        '    """Format a value for Attio API.',
        '',
        '    Attio requires values in specific formats depending on type.',
        '    This helper handles common cases.',
        '    """',
        '    if isinstance(value, bool):',
        '        return value',
        '    if isinstance(value, (int, float)):',
        '        return value',
        '    # For strings, wrap in the expected format',
        '    return value',
        '',
        '',
    ]

    for obj_slug, obj_info in schema.items():
        singular = obj_info["singular_noun"]
        attributes = obj_info["attributes"]

        # Prioritize attributes
        attributes = _prioritize_attributes(attributes, obj_slug)[:MAX_ATTRIBUTES_PER_TOOL]

        # Generate create tool
        lines.extend(_generate_create_tool(obj_slug, singular, attributes))
        lines.append("")

        # Generate update tool
        lines.extend(_generate_update_tool(obj_slug, singular, attributes))
        lines.append("")

        # Generate query tool
        lines.extend(_generate_query_tool(obj_slug, singular, attributes))
        lines.append("")

        # Generate get tool
        lines.extend(_generate_get_tool(obj_slug, singular))
        lines.append("")

        # Generate delete tool
        lines.extend(_generate_delete_tool(obj_slug, singular))
        lines.append("")

    return "\n".join(lines)


def _prioritize_attributes(attributes: list[dict], obj_slug: str) -> list[dict]:
    """Sort attributes by importance.

    Args:
        attributes: List of attribute dicts.
        obj_slug: Object slug.

    Returns:
        Sorted list with most important attributes first.
    """
    priority_map = {
        "people": ["email_addresses", "name", "phone_numbers", "job_title", "company"],
        "companies": ["name", "domains", "description", "industry", "employee_count"],
    }

    priority_names = priority_map.get(obj_slug, [])

    def sort_key(a):
        slug = a["api_slug"]
        if slug in priority_names:
            return (0, priority_names.index(slug))
        if a.get("required"):
            return (1, slug)
        return (2, slug)

    return sorted(attributes, key=sort_key)


def _python_type(attio_type: str) -> str:
    """Map Attio types to Python types.

    Args:
        attio_type: Attio attribute type.

    Returns:
        Python type annotation string.
    """
    type_mapping = {
        "text": "str",
        "number": "float",
        "checkbox": "bool",
        "currency": "float",
        "date": "str",
        "timestamp": "str",
        "select": "str",
        "record-reference": "str",
        "email": "str",
        "phone": "str",
        "domain": "str",
        "location": "str",
    }
    return type_mapping.get(attio_type, "str")


def _generate_create_tool(obj_slug: str, singular: str, attributes: list[dict]) -> list[str]:
    """Generate a create tool for an object.

    Args:
        obj_slug: Object API slug.
        singular: Singular noun for the object.
        attributes: List of attributes.

    Returns:
        List of code lines.
    """
    func_name = f"attio_create_{singular.lower().replace(' ', '_')}"

    # Build parameter list
    params = []
    for a in attributes:
        param_type = _python_type(a["type"])
        default = " = None"
        param_name = a["api_slug"].replace("-", "_")
        params.append(f"    {param_name}: Optional[{param_type}]{default},")

    params_str = "\n".join(params) if params else "    # No writable attributes"

    # Build docstring
    doc_lines = [f'    """Create a new {singular} in Attio.']
    doc_lines.append("")
    doc_lines.append("    Args:")
    for a in attributes[:15]:
        desc = a.get("title", a["api_slug"])
        if a.get("options"):
            desc += f" (options: {', '.join(a['options'][:5])})"
        param_name = a["api_slug"].replace("-", "_")
        doc_lines.append(f"        {param_name}: {desc}")
    if len(attributes) > 15:
        doc_lines.append(f"        ... and {len(attributes) - 15} more parameters")
    doc_lines.append("")
    doc_lines.append("    Returns:")
    doc_lines.append(f"        Success message with the new {singular} ID.")
    doc_lines.append('    """')

    # Build function body
    body = [
        "    client = _get_attio()",
        "    try:",
        "        # Build values dict from non-None arguments",
        "        values = {}",
        "        local_vars = locals()",
        "        # Map parameter names to API slugs",
        "        param_mapping = {",
    ]

    for a in attributes:
        param_name = a["api_slug"].replace("-", "_")
        body.append(f"            '{param_name}': '{a['api_slug']}',")

    body.extend([
        "        }",
        "        for param_name, api_slug in param_mapping.items():",
        "            value = local_vars.get(param_name)",
        "            if value is not None:",
        "                # Attio requires specific value formats",
        "                values[api_slug] = _format_attio_value(value)",
        "",
        "        if not values:",
        f'            return "Error: At least one attribute must be provided to create a {singular}."',
        "",
        f'        payload = {{"data": {{"values": values}}}}',
        f'        response = client.request("POST", "/objects/{obj_slug}/records", json=payload)',
        '        record = response.get("data", {})',
        '        record_id = record.get("id", {}).get("record_id")',
        "",
        f'        return f"Successfully created {singular} with ID: {{record_id}}"',
        "    except Exception as e:",
        f'        return f"Error creating {singular}: {{str(e)}}"',
    ])

    return [
        "@tool",
        f"def {func_name}(",
        params_str,
        ") -> str:",
        *doc_lines,
        *body,
    ]


def _generate_update_tool(obj_slug: str, singular: str, attributes: list[dict]) -> list[str]:
    """Generate an update tool for an object.

    Args:
        obj_slug: Object API slug.
        singular: Singular noun for the object.
        attributes: List of attributes.

    Returns:
        List of code lines.
    """
    func_name = f"attio_update_{singular.lower().replace(' ', '_')}"

    # Build parameter list
    params = ["    record_id: str,"]
    for a in attributes:
        param_type = _python_type(a["type"])
        param_name = a["api_slug"].replace("-", "_")
        params.append(f"    {param_name}: Optional[{param_type}] = None,")

    params_str = "\n".join(params)

    # Build docstring
    doc_lines = [f'    """Update an existing {singular} in Attio.']
    doc_lines.append("")
    doc_lines.append("    Args:")
    doc_lines.append(f"        record_id: The Attio record ID of the {singular}.")
    for a in attributes[:10]:
        param_name = a["api_slug"].replace("-", "_")
        doc_lines.append(f"        {param_name}: {a.get('title', a['api_slug'])}")
    if len(attributes) > 10:
        doc_lines.append(f"        ... and {len(attributes) - 10} more parameters")
    doc_lines.append("")
    doc_lines.append("    Returns:")
    doc_lines.append("        Success message confirming the update.")
    doc_lines.append('    """')

    # Build function body
    body = [
        "    client = _get_attio()",
        "    try:",
        "        # Build values dict from non-None arguments",
        "        values = {}",
        "        local_vars = locals()",
        "        param_mapping = {",
    ]

    for a in attributes:
        param_name = a["api_slug"].replace("-", "_")
        body.append(f"            '{param_name}': '{a['api_slug']}',")

    body.extend([
        "        }",
        "        for param_name, api_slug in param_mapping.items():",
        "            value = local_vars.get(param_name)",
        "            if value is not None:",
        "                values[api_slug] = _format_attio_value(value)",
        "",
        "        if not values:",
        '            return "Error: At least one attribute must be provided to update."',
        "",
        f'        payload = {{"data": {{"values": values}}}}',
        f'        client.request("PATCH", f"/objects/{obj_slug}/records/{{record_id}}", json=payload)',
        "",
        f'        return f"Successfully updated {singular} {{record_id}}"',
        "    except Exception as e:",
        f'        return f"Error updating {singular}: {{str(e)}}"',
    ])

    return [
        "@tool",
        f"def {func_name}(",
        params_str,
        ") -> str:",
        *doc_lines,
        *body,
    ]


def _generate_query_tool(obj_slug: str, singular: str, attributes: list[dict]) -> list[str]:
    """Generate a query tool for an object.

    Args:
        obj_slug: Object API slug.
        singular: Singular noun for the object.
        attributes: List of queryable attributes.

    Returns:
        List of code lines.
    """
    plural = obj_slug  # Usually the slug is plural
    func_name = f"attio_query_{plural.replace('-', '_')}"

    # Build parameter list (limited searchable attributes)
    searchable = [a for a in attributes if a["type"] in ("text", "email", "number", "select")][:8]

    params = []
    for a in searchable:
        param_type = _python_type(a["type"])
        param_name = a["api_slug"].replace("-", "_")
        params.append(f"    {param_name}: Optional[{param_type}] = None,")
    params.append("    limit: int = 10,")

    params_str = "\n".join(params)

    # Build docstring
    doc_lines = [f'    """Query {plural} in Attio by attribute values.']
    doc_lines.append("")
    doc_lines.append("    Args:")
    for a in searchable:
        param_name = a["api_slug"].replace("-", "_")
        doc_lines.append(f"        {param_name}: Filter by {a.get('title', a['api_slug'])}.")
    doc_lines.append("        limit: Maximum results to return (default 10).")
    doc_lines.append("")
    doc_lines.append("    Returns:")
    doc_lines.append(f"        JSON string with matching {plural}.")
    doc_lines.append('    """')

    # Build function body
    body = [
        "    client = _get_attio()",
        "    try:",
        "        # Build filter from provided parameters",
        '        filters = []',
        "        local_vars = locals()",
        "        param_mapping = {",
    ]

    for a in searchable:
        param_name = a["api_slug"].replace("-", "_")
        body.append(f"            '{param_name}': '{a['api_slug']}',")

    body.extend([
        "        }",
        "        for param_name, api_slug in param_mapping.items():",
        "            value = local_vars.get(param_name)",
        "            if value is not None:",
        '                filters.append({api_slug: {"$eq": value}})',
        "",
        '        payload = {"limit": limit}',
        "        if filters:",
        '            payload["filter"] = {"$and": filters}',
        "",
        f'        response = client.request("POST", "/objects/{obj_slug}/records/query", json=payload)',
        '        records = response.get("data", [])',
        "",
        "        if not records:",
        f'            return "No {plural} found."',
        "",
        "        # Format results",
        "        results = []",
        "        for r in records:",
        '            record_data = {"id": r.get("id", {}).get("record_id")}',
        '            for slug, values in r.get("values", {}).items():',
        "                if values:",
        "                    record_data[slug] = values",
        "            results.append(record_data)",
        "",
        f'        return f"Found {{len(records)}} {plural}:\\n" + json.dumps(results, indent=2)',
        "    except Exception as e:",
        f'        return f"Error querying {plural}: {{str(e)}}"',
    ])

    return [
        "@tool",
        f"def {func_name}(",
        params_str,
        ") -> str:",
        *doc_lines,
        *body,
    ]


def _generate_get_tool(obj_slug: str, singular: str) -> list[str]:
    """Generate a get-by-id tool for an object.

    Args:
        obj_slug: Object API slug.
        singular: Singular noun.

    Returns:
        List of code lines.
    """
    func_name = f"attio_get_{singular.lower().replace(' ', '_')}"

    return [
        "@tool",
        f"def {func_name}(record_id: str) -> str:",
        f'    """Get a {singular} by ID from Attio.',
        "",
        "    Args:",
        f"        record_id: The Attio record ID of the {singular}.",
        "",
        "    Returns:",
        f"        JSON string with the {singular} details.",
        '    """',
        "    client = _get_attio()",
        "    try:",
        f'        response = client.request("GET", f"/objects/{obj_slug}/records/{{record_id}}")',
        '        record = response.get("data", {})',
        "",
        "        # Format for display",
        '        result = {"id": record.get("id", {}).get("record_id")}',
        '        for slug, values in record.get("values", {}).items():',
        "            if values:",
        "                result[slug] = values",
        "",
        f'        return f"{singular} {{record_id}}:\\n" + json.dumps(result, indent=2)',
        "    except Exception as e:",
        f'        return f"Error getting {singular}: {{str(e)}}"',
    ]


def _generate_delete_tool(obj_slug: str, singular: str) -> list[str]:
    """Generate a delete tool for an object.

    Args:
        obj_slug: Object API slug.
        singular: Singular noun.

    Returns:
        List of code lines.
    """
    func_name = f"attio_delete_{singular.lower().replace(' ', '_')}"

    return [
        "@tool",
        f"def {func_name}(record_id: str) -> str:",
        f'    """Delete a {singular} from Attio.',
        "",
        "    Args:",
        f"        record_id: The Attio record ID of the {singular} to delete.",
        "",
        "    Returns:",
        "        Success message confirming deletion.",
        '    """',
        "    client = _get_attio()",
        "    try:",
        f'        client.request("DELETE", f"/objects/{obj_slug}/records/{{record_id}}")',
        f'        return f"Successfully deleted {singular} {{record_id}}"',
        "    except Exception as e:",
        f'        return f"Error deleting {singular}: {{str(e)}}"',
    ]
